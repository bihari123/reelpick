{"ast":null,"code":"// src/Components/services/fileUploadService.ts\n\nconst API_BASE_URL = \"http://0.0.0.0:8080\";\nexport class FileUploadService {\n  async initializeUpload(file) {\n    console.log(\"Initializing upload for file:\", file.name);\n    const requestData = {\n      fileName: file.name,\n      fileSize: file.size,\n      totalChunks: Math.ceil(file.size / (1024 * 1024)) // 1MB chunks\n    };\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload/initialize`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json\"\n        },\n        body: JSON.stringify(requestData)\n      });\n      if (!response.ok) {\n        throw new Error(`Server error: ${response.status}`);\n      }\n      const data = await response.json();\n      if (!data.fileId) {\n        throw new Error(\"Invalid response: missing fileId\");\n      }\n      return {\n        fileId: data.fileId,\n        fileName: data.fileName || file.name,\n        fileSize: data.fileSize || file.size\n      };\n    } catch (error) {\n      console.error(\"Initialize upload error:\", error);\n      throw error;\n    }\n  }\n  async uploadChunk(chunk, chunkIndex, totalChunks, fileId, subtitleSegment) {\n    console.log(`Uploading chunk ${chunkIndex + 1}/${totalChunks}`);\n    try {\n      const formData = new FormData();\n      formData.append(\"chunk\", chunk);\n      if (subtitleSegment) {\n        formData.append(\"metadata\", JSON.stringify({\n          startTime: subtitleSegment.startTime,\n          endTime: subtitleSegment.endTime,\n          text: subtitleSegment.text\n        }));\n      }\n      const response = await fetch(`${API_BASE_URL}/api/upload/chunk`, {\n        method: \"POST\",\n        headers: {\n          \"X-File-Id\": fileId,\n          \"X-Chunk-Index\": chunkIndex.toString(),\n          Accept: \"application/json\"\n        },\n        body: formData\n      });\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error(\"Upload error:\", errorText);\n        throw new Error(`Chunk upload failed: ${response.status} - ${errorText}`);\n      }\n      const data = await response.json();\n      console.log(`Chunk ${chunkIndex + 1} upload response:`, data);\n      if (!data.received) {\n        throw new Error(\"Server did not acknowledge chunk receipt\");\n      }\n      return data;\n    } catch (error) {\n      console.error(`Failed to upload chunk ${chunkIndex}:`, error);\n      throw error;\n    }\n  }\n  parseSrtContent(content) {\n    const segments = [];\n    const pattern = /(\\d{2}:\\d{2}:\\d{2},\\d{3}) --> (\\d{2}:\\d{2}:\\d{2},\\d{3})\\n([\\s\\S]*?)(?=\\n\\n|\\n*$)/g;\n    let match;\n    while ((match = pattern.exec(content)) !== null) {\n      segments.push({\n        startTime: match[1],\n        endTime: match[2],\n        text: match[3].trim()\n      });\n    }\n    return segments;\n  }\n  async uploadFile(file, callbacks) {\n    try {\n      console.log(\"Starting upload for file:\", file.name);\n      const initResponse = await this.initializeUpload(file);\n      console.log(\"Upload initialized:\", initResponse);\n      const CHUNK_SIZE = 1024 * 1024; // 1MB\n      const totalChunks = Math.ceil(file.size / CHUNK_SIZE);\n      let uploadedChunks = 0;\n      callbacks.onStatusChange(\"analyzing\");\n\n      // Parse SRT content\n      const content = await file.text();\n      const subtitleSegments = this.parseSrtContent(content);\n\n      // Upload chunks with metadata\n      for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {\n        const start = chunkIndex * CHUNK_SIZE;\n        const end = Math.min(start + CHUNK_SIZE, file.size);\n        const chunk = file.slice(start, end);\n        const subtitleSegment = subtitleSegments[chunkIndex];\n        const response = await this.uploadChunk(chunk, chunkIndex, totalChunks, initResponse.fileId, subtitleSegment);\n        uploadedChunks++;\n        callbacks.onProgress(response.progress);\n        callbacks.onStatusChange(response.status);\n      }\n\n      // Get final analysis results\n      const analysisResponse = await fetch(`${API_BASE_URL}/api/analysis/results?fileId=${initResponse.fileId}`);\n      if (!analysisResponse.ok) {\n        throw new Error(\"Failed to get analysis results\");\n      }\n      const analysisResults = await analysisResponse.json();\n      console.log(\"Upload completed successfully\");\n      callbacks.onStatusChange(\"done\");\n      callbacks.onSuccess();\n      return analysisResults;\n    } catch (error) {\n      console.error(\"Upload failed:\", error);\n      callbacks.onError(error instanceof Error ? error : new Error(String(error)));\n      throw error;\n    }\n  }\n}","map":{"version":3,"names":["API_BASE_URL","FileUploadService","initializeUpload","file","console","log","name","requestData","fileName","fileSize","size","totalChunks","Math","ceil","response","fetch","method","headers","Accept","body","JSON","stringify","ok","Error","status","data","json","fileId","error","uploadChunk","chunk","chunkIndex","subtitleSegment","formData","FormData","append","startTime","endTime","text","toString","errorText","received","parseSrtContent","content","segments","pattern","match","exec","push","trim","uploadFile","callbacks","initResponse","CHUNK_SIZE","uploadedChunks","onStatusChange","subtitleSegments","start","end","min","slice","onProgress","progress","analysisResponse","analysisResults","onSuccess","onError","String"],"sources":["/media/tarun/ITB/code/work/thinkelution/Videolution-Analyzer-App/src/Components/Upload/services/fileUploadService.ts"],"sourcesContent":["// src/Components/services/fileUploadService.ts\n\nimport {\n  UploadProgressCallback,\n  ChunkUploadResponse,\n  UploadInitializeResponse,\n  AnalysisResults,\n} from \"../utils/upload.types\";\n\nconst API_BASE_URL = \"http://0.0.0.0:8080\";\n\ninterface SubtitleSegment {\n  startTime: string;\n  endTime: string;\n  text: string;\n}\n\nexport class FileUploadService {\n  private async initializeUpload(\n    file: File,\n  ): Promise<UploadInitializeResponse> {\n    console.log(\"Initializing upload for file:\", file.name);\n\n    const requestData = {\n      fileName: file.name,\n      fileSize: file.size,\n      totalChunks: Math.ceil(file.size / (1024 * 1024)), // 1MB chunks\n    };\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload/initialize`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json\",\n        },\n        body: JSON.stringify(requestData),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Server error: ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      if (!data.fileId) {\n        throw new Error(\"Invalid response: missing fileId\");\n      }\n\n      return {\n        fileId: data.fileId,\n        fileName: data.fileName || file.name,\n        fileSize: data.fileSize || file.size,\n      };\n    } catch (error) {\n      console.error(\"Initialize upload error:\", error);\n      throw error;\n    }\n  }\n\n  private async uploadChunk(\n    chunk: Blob,\n    chunkIndex: number,\n    totalChunks: number,\n    fileId: string,\n    subtitleSegment?: SubtitleSegment,\n  ): Promise<ChunkUploadResponse> {\n    console.log(`Uploading chunk ${chunkIndex + 1}/${totalChunks}`);\n\n    try {\n      const formData = new FormData();\n      formData.append(\"chunk\", chunk);\n\n      if (subtitleSegment) {\n        formData.append(\n          \"metadata\",\n          JSON.stringify({\n            startTime: subtitleSegment.startTime,\n            endTime: subtitleSegment.endTime,\n            text: subtitleSegment.text,\n          }),\n        );\n      }\n\n      const response = await fetch(`${API_BASE_URL}/api/upload/chunk`, {\n        method: \"POST\",\n        headers: {\n          \"X-File-Id\": fileId,\n          \"X-Chunk-Index\": chunkIndex.toString(),\n          Accept: \"application/json\",\n        },\n        body: formData,\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error(\"Upload error:\", errorText);\n        throw new Error(\n          `Chunk upload failed: ${response.status} - ${errorText}`,\n        );\n      }\n\n      const data = await response.json();\n      console.log(`Chunk ${chunkIndex + 1} upload response:`, data);\n\n      if (!data.received) {\n        throw new Error(\"Server did not acknowledge chunk receipt\");\n      }\n\n      return data;\n    } catch (error) {\n      console.error(`Failed to upload chunk ${chunkIndex}:`, error);\n      throw error;\n    }\n  }\n\n  private parseSrtContent(content: string): SubtitleSegment[] {\n    const segments: SubtitleSegment[] = [];\n    const pattern =\n      /(\\d{2}:\\d{2}:\\d{2},\\d{3}) --> (\\d{2}:\\d{2}:\\d{2},\\d{3})\\n([\\s\\S]*?)(?=\\n\\n|\\n*$)/g;\n\n    let match;\n    while ((match = pattern.exec(content)) !== null) {\n      segments.push({\n        startTime: match[1],\n        endTime: match[2],\n        text: match[3].trim(),\n      });\n    }\n\n    return segments;\n  }\n\n  public async uploadFile(\n    file: File,\n    callbacks: UploadProgressCallback,\n  ): Promise<AnalysisResults> {\n    try {\n      console.log(\"Starting upload for file:\", file.name);\n\n      const initResponse = await this.initializeUpload(file);\n      console.log(\"Upload initialized:\", initResponse);\n\n      const CHUNK_SIZE = 1024 * 1024; // 1MB\n      const totalChunks = Math.ceil(file.size / CHUNK_SIZE);\n      let uploadedChunks = 0;\n\n      callbacks.onStatusChange(\"analyzing\");\n\n      // Parse SRT content\n      const content = await file.text();\n      const subtitleSegments = this.parseSrtContent(content);\n\n      // Upload chunks with metadata\n      for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {\n        const start = chunkIndex * CHUNK_SIZE;\n        const end = Math.min(start + CHUNK_SIZE, file.size);\n        const chunk = file.slice(start, end);\n\n        const subtitleSegment = subtitleSegments[chunkIndex];\n\n        const response = await this.uploadChunk(\n          chunk,\n          chunkIndex,\n          totalChunks,\n          initResponse.fileId,\n          subtitleSegment,\n        );\n\n        uploadedChunks++;\n        callbacks.onProgress(response.progress);\n        callbacks.onStatusChange(response.status);\n      }\n\n      // Get final analysis results\n      const analysisResponse = await fetch(\n        `${API_BASE_URL}/api/analysis/results?fileId=${initResponse.fileId}`,\n      );\n\n      if (!analysisResponse.ok) {\n        throw new Error(\"Failed to get analysis results\");\n      }\n\n      const analysisResults: AnalysisResults = await analysisResponse.json();\n\n      console.log(\"Upload completed successfully\");\n      callbacks.onStatusChange(\"done\");\n      callbacks.onSuccess();\n\n      return analysisResults;\n    } catch (error) {\n      console.error(\"Upload failed:\", error);\n      callbacks.onError(\n        error instanceof Error ? error : new Error(String(error)),\n      );\n      throw error;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}