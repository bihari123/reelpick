{"ast":null,"code":"// src/Components/services/fileUploadService.ts\n\nconst API_BASE_URL = \"http://0.0.0.0:8080\";\nexport class FileUploadService {\n  async initializeUpload(file) {\n    console.log(\"Initializing upload for file:\", file.name);\n    const requestData = {\n      fileName: file.name,\n      fileSize: file.size,\n      totalChunks: Math.ceil(file.size / (1024 * 1024)) // 1MB chunks\n    };\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload/initialize`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json\"\n        },\n        body: JSON.stringify(requestData)\n      });\n      if (!response.ok) {\n        throw new Error(`Server error: ${response.status}`);\n      }\n      const data = await response.json();\n      if (!data.fileId) {\n        throw new Error(\"Invalid response: missing fileId\");\n      }\n      return {\n        fileId: data.fileId,\n        fileName: data.fileName || file.name,\n        fileSize: data.fileSize || file.size\n      };\n    } catch (error) {\n      console.error(\"Initialize upload error:\", error);\n      throw error;\n    }\n  }\n  async uploadChunk(chunk, chunkIndex, totalChunks, fileId, startTime, endTime, text) {\n    console.log(`Uploading chunk ${chunkIndex + 1}/${totalChunks}`);\n    const formData = new FormData();\n    formData.append(\"chunk\", chunk);\n    formData.append(\"metadata\", JSON.stringify({\n      startTime,\n      endTime,\n      text\n    }));\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload/chunk`, {\n        method: \"POST\",\n        headers: {\n          \"X-File-Id\": fileId,\n          \"X-Chunk-Index\": chunkIndex.toString(),\n          Accept: \"application/json\"\n        },\n        body: formData\n      });\n      if (!response.ok) {\n        throw new Error(`Chunk upload failed: ${response.status}`);\n      }\n      const data = await response.json();\n      if (!data.received) {\n        throw new Error(\"Chunk upload failed\");\n      }\n      return {\n        received: data.received,\n        status: data.status,\n        progress: data.progress,\n        uploadedSize: data.uploadedSize,\n        totalSize: data.totalSize,\n        message: data.message,\n        analysisResult: data.analysisResult\n      };\n    } catch (error) {\n      console.error(`Failed to upload chunk ${chunkIndex}:`, error);\n      throw error;\n    }\n  }\n  async uploadFile(file, callbacks) {\n    try {\n      console.log(\"Starting upload for file:\", file.name);\n      const initResponse = await this.initializeUpload(file);\n      console.log(\"Upload initialized:\", initResponse);\n      const CHUNK_SIZE = 1024 * 1024; // 1MB\n      const totalChunks = Math.ceil(file.size / CHUNK_SIZE);\n      let uploadedChunks = 0;\n      callbacks.onStatusChange(\"analyzing\");\n\n      // Parse SRT content for metadata\n      const text = await file.text();\n      const srtPattern = /(\\d{2}:\\d{2}:\\d{2},\\d{3}) --> (\\d{2}:\\d{2}:\\d{2},\\d{3})\\n(.*?)(?=\\n\\n|\\n*$)/gs;\n      const matches = Array.from(text.matchAll(srtPattern));\n\n      // Upload chunks with metadata\n      for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {\n        const start = chunkIndex * CHUNK_SIZE;\n        const end = Math.min(start + CHUNK_SIZE, file.size);\n        const chunk = file.slice(start, end);\n\n        // Get corresponding subtitle metadata if available\n        const metadata = matches[chunkIndex] ? {\n          startTime: matches[chunkIndex][1],\n          endTime: matches[chunkIndex][2],\n          text: matches[chunkIndex][3].trim()\n        } : undefined;\n        const response = await this.uploadChunk(chunk, chunkIndex, totalChunks, initResponse.fileId, metadata === null || metadata === void 0 ? void 0 : metadata.startTime, metadata === null || metadata === void 0 ? void 0 : metadata.endTime, metadata === null || metadata === void 0 ? void 0 : metadata.text);\n        uploadedChunks++;\n        callbacks.onProgress(response.progress);\n        callbacks.onStatusChange(response.status);\n      }\n      console.log(\"Upload completed successfully\");\n      callbacks.onStatusChange(\"done\");\n      callbacks.onSuccess();\n    } catch (error) {\n      console.error(\"Upload failed:\", error);\n      callbacks.onError(error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n}","map":{"version":3,"names":["API_BASE_URL","FileUploadService","initializeUpload","file","console","log","name","requestData","fileName","fileSize","size","totalChunks","Math","ceil","response","fetch","method","headers","Accept","body","JSON","stringify","ok","Error","status","data","json","fileId","error","uploadChunk","chunk","chunkIndex","startTime","endTime","text","formData","FormData","append","toString","received","progress","uploadedSize","totalSize","message","analysisResult","uploadFile","callbacks","initResponse","CHUNK_SIZE","uploadedChunks","onStatusChange","srtPattern","matches","Array","from","matchAll","start","end","min","slice","metadata","trim","undefined","onProgress","onSuccess","onError","String"],"sources":["/media/tarun/ITB/code/work/thinkelution/Videolution-Analyzer-App/src/Components/Upload/services/fileUploadService.ts"],"sourcesContent":["// src/Components/services/fileUploadService.ts\n\nimport {\n  UploadProgressCallback,\n  ChunkUploadResponse,\n  UploadInitializeResponse,\n} from \"../utils/upload.types\";\n\nconst API_BASE_URL = \"http://0.0.0.0:8080\";\n\nexport class FileUploadService {\n  private async initializeUpload(\n    file: File,\n  ): Promise<UploadInitializeResponse> {\n    console.log(\"Initializing upload for file:\", file.name);\n\n    const requestData = {\n      fileName: file.name,\n      fileSize: file.size,\n      totalChunks: Math.ceil(file.size / (1024 * 1024)), // 1MB chunks\n    };\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload/initialize`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json\",\n        },\n        body: JSON.stringify(requestData),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Server error: ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      if (!data.fileId) {\n        throw new Error(\"Invalid response: missing fileId\");\n      }\n\n      return {\n        fileId: data.fileId,\n        fileName: data.fileName || file.name,\n        fileSize: data.fileSize || file.size,\n      };\n    } catch (error) {\n      console.error(\"Initialize upload error:\", error);\n      throw error;\n    }\n  }\n\n  private async uploadChunk(\n    chunk: Blob,\n    chunkIndex: number,\n    totalChunks: number,\n    fileId: string,\n    startTime?: string,\n    endTime?: string,\n    text?: string,\n  ): Promise<ChunkUploadResponse> {\n    console.log(`Uploading chunk ${chunkIndex + 1}/${totalChunks}`);\n\n    const formData = new FormData();\n    formData.append(\"chunk\", chunk);\n    formData.append(\n      \"metadata\",\n      JSON.stringify({\n        startTime,\n        endTime,\n        text,\n      }),\n    );\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload/chunk`, {\n        method: \"POST\",\n        headers: {\n          \"X-File-Id\": fileId,\n          \"X-Chunk-Index\": chunkIndex.toString(),\n          Accept: \"application/json\",\n        },\n        body: formData,\n      });\n\n      if (!response.ok) {\n        throw new Error(`Chunk upload failed: ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      if (!data.received) {\n        throw new Error(\"Chunk upload failed\");\n      }\n\n      return {\n        received: data.received,\n        status: data.status,\n        progress: data.progress,\n        uploadedSize: data.uploadedSize,\n        totalSize: data.totalSize,\n        message: data.message,\n        analysisResult: data.analysisResult,\n      };\n    } catch (error) {\n      console.error(`Failed to upload chunk ${chunkIndex}:`, error);\n      throw error;\n    }\n  }\n\n  public async uploadFile(\n    file: File,\n    callbacks: UploadProgressCallback,\n  ): Promise<void> {\n    try {\n      console.log(\"Starting upload for file:\", file.name);\n\n      const initResponse = await this.initializeUpload(file);\n      console.log(\"Upload initialized:\", initResponse);\n\n      const CHUNK_SIZE = 1024 * 1024; // 1MB\n      const totalChunks = Math.ceil(file.size / CHUNK_SIZE);\n      let uploadedChunks = 0;\n\n      callbacks.onStatusChange(\"analyzing\");\n\n      // Parse SRT content for metadata\n      const text = await file.text();\n      const srtPattern =\n        /(\\d{2}:\\d{2}:\\d{2},\\d{3}) --> (\\d{2}:\\d{2}:\\d{2},\\d{3})\\n(.*?)(?=\\n\\n|\\n*$)/gs;\n      const matches = Array.from(text.matchAll(srtPattern));\n\n      // Upload chunks with metadata\n      for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {\n        const start = chunkIndex * CHUNK_SIZE;\n        const end = Math.min(start + CHUNK_SIZE, file.size);\n        const chunk = file.slice(start, end);\n\n        // Get corresponding subtitle metadata if available\n        const metadata = matches[chunkIndex]\n          ? {\n            startTime: matches[chunkIndex][1],\n            endTime: matches[chunkIndex][2],\n            text: matches[chunkIndex][3].trim(),\n          }\n          : undefined;\n\n        const response = await this.uploadChunk(\n          chunk,\n          chunkIndex,\n          totalChunks,\n          initResponse.fileId,\n          metadata?.startTime,\n          metadata?.endTime,\n          metadata?.text,\n        );\n\n        uploadedChunks++;\n        callbacks.onProgress(response.progress);\n        callbacks.onStatusChange(response.status);\n      }\n\n      console.log(\"Upload completed successfully\");\n      callbacks.onStatusChange(\"done\");\n      callbacks.onSuccess();\n    } catch (error) {\n      console.error(\"Upload failed:\", error);\n      callbacks.onError(\n        error instanceof Error ? error : new Error(String(error)),\n      );\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}