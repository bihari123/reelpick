{"ast":null,"code":"// src/services/fileUploadService.ts\n\nimport { FileProcessingService } from \"./fileProcessingService\";\nexport class FileUploadService {\n  constructor() {\n    this.processingService = void 0;\n    this.API_BASE_URL = \"http://0.0.0.0:8080\";\n    this.processingService = new FileProcessingService();\n  }\n  async initializeUpload(file) {\n    console.log(\"Initializing upload for file:\", file.name);\n    const requestData = {\n      fileName: file.name,\n      fileSize: file.size,\n      totalChunks: Math.ceil(file.size / (1024 * 1024))\n    };\n    try {\n      const response = await fetch(`${this.API_BASE_URL}/api/upload/initialize`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json\"\n        },\n        body: JSON.stringify(requestData)\n      });\n      const responseText = await response.text();\n      if (!responseText) {\n        throw new Error(\"Empty response received from server\");\n      }\n      const data = JSON.parse(responseText);\n      if (!response.ok) {\n        throw new Error(data.error || `Server error: ${response.status}`);\n      }\n      return {\n        fileId: data.fileId,\n        fileName: data.fileName || file.name,\n        fileSize: data.fileSize || file.size\n      };\n    } catch (error) {\n      console.error(\"Initialize upload error:\", error);\n      throw error;\n    }\n  }\n  async uploadChunk(chunk, chunkIndex, totalChunks, fileId) {\n    try {\n      const response = await fetch(`${this.API_BASE_URL}/api/upload/chunk`, {\n        method: \"POST\",\n        headers: {\n          \"X-File-Id\": fileId,\n          \"X-Chunk-Index\": chunkIndex.toString(),\n          Accept: \"application/json\",\n          \"Content-Type\": \"application/octet-stream\"\n        },\n        body: chunk\n      });\n      const responseText = await response.text();\n      if (!responseText) {\n        throw new Error(\"Empty response received from server\");\n      }\n      const data = JSON.parse(responseText);\n      if (!response.ok) {\n        throw new Error(data.error || `Chunk upload failed: ${response.status}`);\n      }\n      return {\n        received: data.received,\n        status: data.status,\n        progress: data.progress,\n        uploadedSize: data.uploadedSize,\n        totalSize: data.totalSize,\n        message: data.message\n      };\n    } catch (error) {\n      console.error(`Failed to upload chunk ${chunkIndex}:`, error);\n      throw error;\n    }\n  }\n  async uploadFile(file, callbacks) {\n    try {\n      const initResponse = await this.initializeUpload(file);\n      console.log(\"Upload initialized:\", initResponse);\n      const CHUNK_SIZE = 1024 * 1024; // 1MB\n      const totalChunks = Math.ceil(file.size / CHUNK_SIZE);\n      callbacks.onStatusChange(\"uploading\");\n      for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {\n        const start = chunkIndex * CHUNK_SIZE;\n        const end = Math.min(start + CHUNK_SIZE, file.size);\n        const chunk = file.slice(start, end);\n        const response = await this.uploadChunk(chunk, chunkIndex, totalChunks, initResponse.fileId);\n        callbacks.onProgress(response.progress);\n        callbacks.onStatusChange(response.status);\n      }\n\n      // Start polling for processing status\n      this.processingService.startPolling(initResponse.fileId, status => {\n        callbacks.onStatusChange(status.status);\n        callbacks.onProgress(status.progress);\n      }, result => {\n        callbacks.onStatusChange(\"completed\");\n        callbacks.onSuccess();\n      }, error => {\n        callbacks.onError(error);\n      });\n    } catch (error) {\n      console.error(\"Upload failed:\", error);\n      this.processingService.stopPolling();\n      callbacks.onError(error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n  cancelProcessing() {\n    this.processingService.stopPolling();\n  }\n}","map":{"version":3,"names":["FileProcessingService","FileUploadService","constructor","processingService","API_BASE_URL","initializeUpload","file","console","log","name","requestData","fileName","fileSize","size","totalChunks","Math","ceil","response","fetch","method","headers","Accept","body","JSON","stringify","responseText","text","Error","data","parse","ok","error","status","fileId","uploadChunk","chunk","chunkIndex","toString","received","progress","uploadedSize","totalSize","message","uploadFile","callbacks","initResponse","CHUNK_SIZE","onStatusChange","start","end","min","slice","onProgress","startPolling","result","onSuccess","onError","stopPolling","String","cancelProcessing"],"sources":["/media/tarun/ITB/code/work/thinkelution/Videolution-Analyzer-App/src/Components/Upload/services/fileUploadService.ts"],"sourcesContent":["// src/services/fileUploadService.ts\n\nimport {\n\tUploadProgressCallback,\n\tChunkUploadResponse,\n\tUploadInitializeResponse,\n\tProcessingStatus,\n\tProcessingStep,\n} from \"../utils/upload.types\";\nimport { FileProcessingService } from \"./fileProcessingService\";\n\nexport class FileUploadService {\n\tprivate processingService: FileProcessingService;\n\tprivate API_BASE_URL = \"http://0.0.0.0:8080\";\n\n\tconstructor() {\n\t\tthis.processingService = new FileProcessingService();\n\t}\n\n\tprivate async initializeUpload(\n\t\tfile: File,\n\t): Promise<UploadInitializeResponse> {\n\t\tconsole.log(\"Initializing upload for file:\", file.name);\n\n\t\tconst requestData = {\n\t\t\tfileName: file.name,\n\t\t\tfileSize: file.size,\n\t\t\ttotalChunks: Math.ceil(file.size / (1024 * 1024)),\n\t\t};\n\n\t\ttry {\n\t\t\tconst response = await fetch(\n\t\t\t\t`${this.API_BASE_URL}/api/upload/initialize`,\n\t\t\t\t{\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\t\tAccept: \"application/json\",\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify(requestData),\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tconst responseText = await response.text();\n\t\t\tif (!responseText) {\n\t\t\t\tthrow new Error(\"Empty response received from server\");\n\t\t\t}\n\n\t\t\tconst data = JSON.parse(responseText);\n\t\t\tif (!response.ok) {\n\t\t\t\tthrow new Error(data.error || `Server error: ${response.status}`);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tfileId: data.fileId,\n\t\t\t\tfileName: data.fileName || file.name,\n\t\t\t\tfileSize: data.fileSize || file.size,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Initialize upload error:\", error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate async uploadChunk(\n\t\tchunk: Blob,\n\t\tchunkIndex: number,\n\t\ttotalChunks: number,\n\t\tfileId: string,\n\t): Promise<ChunkUploadResponse> {\n\t\ttry {\n\t\t\tconst response = await fetch(`${this.API_BASE_URL}/api/upload/chunk`, {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: {\n\t\t\t\t\t\"X-File-Id\": fileId,\n\t\t\t\t\t\"X-Chunk-Index\": chunkIndex.toString(),\n\t\t\t\t\tAccept: \"application/json\",\n\t\t\t\t\t\"Content-Type\": \"application/octet-stream\",\n\t\t\t\t},\n\t\t\t\tbody: chunk,\n\t\t\t});\n\n\t\t\tconst responseText = await response.text();\n\t\t\tif (!responseText) {\n\t\t\t\tthrow new Error(\"Empty response received from server\");\n\t\t\t}\n\n\t\t\tconst data = JSON.parse(responseText);\n\t\t\tif (!response.ok) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\tdata.error || `Chunk upload failed: ${response.status}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\treceived: data.received,\n\t\t\t\tstatus: data.status,\n\t\t\t\tprogress: data.progress,\n\t\t\t\tuploadedSize: data.uploadedSize,\n\t\t\t\ttotalSize: data.totalSize,\n\t\t\t\tmessage: data.message,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconsole.error(`Failed to upload chunk ${chunkIndex}:`, error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tpublic async uploadFile(\n\t\tfile: File,\n\t\tcallbacks: UploadProgressCallback,\n\t): Promise<void> {\n\t\ttry {\n\t\t\tconst initResponse = await this.initializeUpload(file);\n\t\t\tconsole.log(\"Upload initialized:\", initResponse);\n\n\t\t\tconst CHUNK_SIZE = 1024 * 1024; // 1MB\n\t\t\tconst totalChunks = Math.ceil(file.size / CHUNK_SIZE);\n\n\t\t\tcallbacks.onStatusChange(\"uploading\");\n\n\t\t\tfor (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {\n\t\t\t\tconst start = chunkIndex * CHUNK_SIZE;\n\t\t\t\tconst end = Math.min(start + CHUNK_SIZE, file.size);\n\t\t\t\tconst chunk = file.slice(start, end);\n\n\t\t\t\tconst response = await this.uploadChunk(\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkIndex,\n\t\t\t\t\ttotalChunks,\n\t\t\t\t\tinitResponse.fileId,\n\t\t\t\t);\n\n\t\t\t\tcallbacks.onProgress(response.progress);\n\t\t\t\tcallbacks.onStatusChange(response.status);\n\t\t\t}\n\n\t\t\t// Start polling for processing status\n\t\t\tthis.processingService.startPolling(\n\t\t\t\tinitResponse.fileId,\n\t\t\t\t(status: ProcessingStatus) => {\n\t\t\t\t\tcallbacks.onStatusChange(status.status);\n\t\t\t\t\tcallbacks.onProgress(status.progress);\n\t\t\t\t},\n\t\t\t\t(result) => {\n\t\t\t\t\tcallbacks.onStatusChange(\"completed\");\n\t\t\t\t\tcallbacks.onSuccess();\n\t\t\t\t},\n\t\t\t\t(error) => {\n\t\t\t\t\tcallbacks.onError(error);\n\t\t\t\t},\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Upload failed:\", error);\n\t\t\tthis.processingService.stopPolling();\n\t\t\tcallbacks.onError(\n\t\t\t\terror instanceof Error ? error : new Error(String(error)),\n\t\t\t);\n\t\t}\n\t}\n\n\tpublic cancelProcessing(): void {\n\t\tthis.processingService.stopPolling();\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}