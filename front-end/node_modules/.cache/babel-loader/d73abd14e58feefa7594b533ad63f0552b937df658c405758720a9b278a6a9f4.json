{"ast":null,"code":"// src/Components/services/fileUploadService.ts\n\nconst API_BASE_URL = \"http://0.0.0.0:8080\";\nexport class FileUploadService {\n  async initializeUpload(file, totalSegments) {\n    console.log(\"Initializing upload for file:\", file.name);\n    const requestData = {\n      fileName: file.name,\n      fileSize: file.size,\n      totalChunks: totalSegments // Now using number of subtitle segments\n    };\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload/initialize`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json\"\n        },\n        body: JSON.stringify(requestData)\n      });\n      if (!response.ok) {\n        throw new Error(`Server error: ${response.status}`);\n      }\n      const data = await response.json();\n      if (!data.fileId) {\n        throw new Error(\"Invalid response: missing fileId\");\n      }\n      return {\n        fileId: data.fileId,\n        fileName: data.fileName || file.name,\n        fileSize: data.fileSize || file.size\n      };\n    } catch (error) {\n      console.error(\"Initialize upload error:\", error);\n      throw error;\n    }\n  }\n  parseSrtContent(content) {\n    const segments = [];\n    // Skip segment numbers and empty lines\n    const pattern = /(\\d{2}:\\d{2}:\\d{2},\\d{3}) --> (\\d{2}:\\d{2}:\\d{2},\\d{3})\\n([\\s\\S]*?)(?=\\n\\n|\\n*$)/g;\n    let match;\n    while ((match = pattern.exec(content)) !== null) {\n      segments.push({\n        startTime: match[1],\n        endTime: match[2],\n        text: match[3].trim()\n      });\n    }\n    return segments;\n  }\n  async uploadSegment(segment, segmentIndex, totalSegments, fileId) {\n    console.log(`Uploading segment ${segmentIndex + 1}/${totalSegments}`, segment);\n    const formData = new FormData();\n    formData.append(\"metadata\", JSON.stringify(segment));\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload/chunk`, {\n        method: \"POST\",\n        headers: {\n          \"X-File-Id\": fileId,\n          \"X-Chunk-Index\": segmentIndex.toString(),\n          Accept: \"application/json\"\n        },\n        body: formData\n      });\n      if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`Segment upload failed: ${response.status} - ${errorText}`);\n      }\n      const data = await response.json();\n      console.log(`Segment ${segmentIndex + 1} response:`, data);\n      return data;\n    } catch (error) {\n      console.error(`Failed to upload segment ${segmentIndex}:`, error);\n      throw error;\n    }\n  }\n  async uploadFile(file, callbacks) {\n    try {\n      console.log(\"Starting upload for file:\", file.name);\n\n      // First read the file content\n      const content = await file.text();\n      const subtitleSegments = this.parseSrtContent(content);\n      console.log(\"Parsed subtitle segments:\", subtitleSegments);\n      if (subtitleSegments.length === 0) {\n        throw new Error(\"No subtitle segments found in file\");\n      }\n      const initResponse = await this.initializeUpload(file, subtitleSegments.length);\n      console.log(\"Upload initialized:\", initResponse);\n      callbacks.onStatusChange(\"analyzing\");\n\n      // Upload segments\n      for (let segmentIndex = 0; segmentIndex < subtitleSegments.length; segmentIndex++) {\n        const segment = subtitleSegments[segmentIndex];\n        const response = await this.uploadSegment(segment, segmentIndex, subtitleSegments.length, initResponse.fileId);\n        callbacks.onProgress((segmentIndex + 1) * 100 / subtitleSegments.length);\n        callbacks.onStatusChange(response.status);\n\n        // Small delay between segments to prevent overwhelming the server\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n\n      // Get final analysis results\n      const analysisResponse = await fetch(`${API_BASE_URL}/api/analysis/results?fileId=${initResponse.fileId}`);\n      if (analysisResponse.ok) {\n        const finalResults = await analysisResponse.json();\n        console.log(\"Final analysis results:\", finalResults);\n      }\n      console.log(\"Upload and analysis completed successfully\");\n      callbacks.onStatusChange(\"done\");\n      callbacks.onSuccess();\n    } catch (error) {\n      console.error(\"Upload failed:\", error);\n      callbacks.onError(error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n}","map":{"version":3,"names":["API_BASE_URL","FileUploadService","initializeUpload","file","totalSegments","console","log","name","requestData","fileName","fileSize","size","totalChunks","response","fetch","method","headers","Accept","body","JSON","stringify","ok","Error","status","data","json","fileId","error","parseSrtContent","content","segments","pattern","match","exec","push","startTime","endTime","text","trim","uploadSegment","segment","segmentIndex","formData","FormData","append","toString","errorText","uploadFile","callbacks","subtitleSegments","length","initResponse","onStatusChange","onProgress","Promise","resolve","setTimeout","analysisResponse","finalResults","onSuccess","onError","String"],"sources":["/media/tarun/ITB/code/work/thinkelution/Videolution-Analyzer-App/src/Components/Upload/services/fileUploadService.ts"],"sourcesContent":["// src/Components/services/fileUploadService.ts\n\nimport {\n  UploadProgressCallback,\n  ChunkUploadResponse,\n  UploadInitializeResponse,\n} from \"../utils/upload.types\";\n\nconst API_BASE_URL = \"http://0.0.0.0:8080\";\n\ninterface SubtitleSegment {\n  startTime: string;\n  endTime: string;\n  text: string;\n}\n\nexport class FileUploadService {\n  private async initializeUpload(\n    file: File,\n    totalSegments: number,\n  ): Promise<UploadInitializeResponse> {\n    console.log(\"Initializing upload for file:\", file.name);\n\n    const requestData = {\n      fileName: file.name,\n      fileSize: file.size,\n      totalChunks: totalSegments, // Now using number of subtitle segments\n    };\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload/initialize`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json\",\n        },\n        body: JSON.stringify(requestData),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Server error: ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      if (!data.fileId) {\n        throw new Error(\"Invalid response: missing fileId\");\n      }\n\n      return {\n        fileId: data.fileId,\n        fileName: data.fileName || file.name,\n        fileSize: data.fileSize || file.size,\n      };\n    } catch (error) {\n      console.error(\"Initialize upload error:\", error);\n      throw error;\n    }\n  }\n\n  private parseSrtContent(content: string): SubtitleSegment[] {\n    const segments: SubtitleSegment[] = [];\n    // Skip segment numbers and empty lines\n    const pattern =\n      /(\\d{2}:\\d{2}:\\d{2},\\d{3}) --> (\\d{2}:\\d{2}:\\d{2},\\d{3})\\n([\\s\\S]*?)(?=\\n\\n|\\n*$)/g;\n\n    let match;\n    while ((match = pattern.exec(content)) !== null) {\n      segments.push({\n        startTime: match[1],\n        endTime: match[2],\n        text: match[3].trim(),\n      });\n    }\n\n    return segments;\n  }\n\n  private async uploadSegment(\n    segment: SubtitleSegment,\n    segmentIndex: number,\n    totalSegments: number,\n    fileId: string,\n  ): Promise<ChunkUploadResponse> {\n    console.log(\n      `Uploading segment ${segmentIndex + 1}/${totalSegments}`,\n      segment,\n    );\n\n    const formData = new FormData();\n    formData.append(\"metadata\", JSON.stringify(segment));\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload/chunk`, {\n        method: \"POST\",\n        headers: {\n          \"X-File-Id\": fileId,\n          \"X-Chunk-Index\": segmentIndex.toString(),\n          Accept: \"application/json\",\n        },\n        body: formData,\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(\n          `Segment upload failed: ${response.status} - ${errorText}`,\n        );\n      }\n\n      const data = await response.json();\n      console.log(`Segment ${segmentIndex + 1} response:`, data);\n\n      return data;\n    } catch (error) {\n      console.error(`Failed to upload segment ${segmentIndex}:`, error);\n      throw error;\n    }\n  }\n\n  public async uploadFile(\n    file: File,\n    callbacks: UploadProgressCallback,\n  ): Promise<void> {\n    try {\n      console.log(\"Starting upload for file:\", file.name);\n\n      // First read the file content\n      const content = await file.text();\n      const subtitleSegments = this.parseSrtContent(content);\n      console.log(\"Parsed subtitle segments:\", subtitleSegments);\n\n      if (subtitleSegments.length === 0) {\n        throw new Error(\"No subtitle segments found in file\");\n      }\n\n      const initResponse = await this.initializeUpload(\n        file,\n        subtitleSegments.length,\n      );\n      console.log(\"Upload initialized:\", initResponse);\n\n      callbacks.onStatusChange(\"analyzing\");\n\n      // Upload segments\n      for (\n        let segmentIndex = 0;\n        segmentIndex < subtitleSegments.length;\n        segmentIndex++\n      ) {\n        const segment = subtitleSegments[segmentIndex];\n\n        const response = await this.uploadSegment(\n          segment,\n          segmentIndex,\n          subtitleSegments.length,\n          initResponse.fileId,\n        );\n\n        callbacks.onProgress(\n          ((segmentIndex + 1) * 100) / subtitleSegments.length,\n        );\n        callbacks.onStatusChange(response.status);\n\n        // Small delay between segments to prevent overwhelming the server\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      }\n\n      // Get final analysis results\n      const analysisResponse = await fetch(\n        `${API_BASE_URL}/api/analysis/results?fileId=${initResponse.fileId}`,\n      );\n\n      if (analysisResponse.ok) {\n        const finalResults = await analysisResponse.json();\n        console.log(\"Final analysis results:\", finalResults);\n      }\n\n      console.log(\"Upload and analysis completed successfully\");\n      callbacks.onStatusChange(\"done\");\n      callbacks.onSuccess();\n    } catch (error) {\n      console.error(\"Upload failed:\", error);\n      callbacks.onError(\n        error instanceof Error ? error : new Error(String(error)),\n      );\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}