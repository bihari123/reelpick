{"ast":null,"code":"// src/components/Upload/services/fileUploadService.ts\n\nimport { API_ENDPOINTS } from \"../../../config/api.config\";\nimport { UPLOAD_CONFIG } from \"../constants/upload.constants\";\nexport class FileUploadService {\n  async createChunk(file, start, end) {\n    return file.slice(start, end);\n  }\n  async initializeUpload(file) {\n    const response = await fetch(API_ENDPOINTS.UPLOAD.INITIALIZE, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        fileName: file.name,\n        fileSize: file.size,\n        totalChunks: Math.ceil(file.size / UPLOAD_CONFIG.CHUNK_SIZE)\n      })\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to initialize upload\");\n    }\n    return response.json();\n  }\n  async uploadChunk(chunk, chunkIndex, fileId, retryCount = 0) {\n    const formData = new FormData();\n    formData.append(\"chunk\", chunk);\n    formData.append(\"chunkIndex\", chunkIndex.toString());\n    formData.append(\"fileId\", fileId);\n    try {\n      const response = await fetch(API_ENDPOINTS.UPLOAD.CHUNK, {\n        method: \"POST\",\n        body: formData\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return response.json();\n    } catch (error) {\n      if (retryCount < UPLOAD_CONFIG.RETRY_ATTEMPTS) {\n        // Wait before retrying\n        await new Promise(resolve => setTimeout(resolve, UPLOAD_CONFIG.RETRY_DELAY));\n        return this.uploadChunk(chunk, chunkIndex, fileId, retryCount + 1);\n      }\n      throw error;\n    }\n  }\n  async verifyUpload(fileId) {\n    const response = await fetch(`${API_ENDPOINTS.UPLOAD.VERIFY}/${fileId}`, {\n      method: \"POST\"\n    });\n    if (!response.ok) {\n      throw new Error(\"Upload verification failed\");\n    }\n    const result = await response.json();\n    return result.verified;\n  }\n  async uploadFile(file, callbacks) {\n    try {\n      // Initialize upload\n      const {\n        fileId\n      } = await this.initializeUpload(file);\n      const totalChunks = Math.ceil(file.size / UPLOAD_CONFIG.CHUNK_SIZE);\n      let uploadedChunks = 0;\n\n      // Upload chunks\n      for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {\n        const start = chunkIndex * UPLOAD_CONFIG.CHUNK_SIZE;\n        const end = Math.min(start + UPLOAD_CONFIG.CHUNK_SIZE, file.size);\n\n        // Create and upload chunk\n        const chunk = await this.createChunk(file, start, end);\n        await this.uploadChunk(chunk, chunkIndex, fileId);\n\n        // Update progress\n        uploadedChunks++;\n        const progress = Math.round(uploadedChunks / totalChunks * 100);\n        callbacks.onProgress(progress);\n\n        // Update status based on progress thresholds\n        if (progress >= 30 && progress < 60) {\n          callbacks.onStatusChange(\"processing\");\n        } else if (progress >= 60 && progress < 100) {\n          callbacks.onStatusChange(\"finalizing\");\n        }\n      }\n\n      // Verify upload\n      const verified = await this.verifyUpload(fileId);\n      if (!verified) {\n        throw new Error(\"Upload verification failed\");\n      }\n      callbacks.onStatusChange(\"done\");\n      callbacks.onSuccess();\n    } catch (error) {\n      callbacks.onError(error);\n    }\n  }\n}","map":{"version":3,"names":["API_ENDPOINTS","UPLOAD_CONFIG","FileUploadService","createChunk","file","start","end","slice","initializeUpload","response","fetch","UPLOAD","INITIALIZE","method","headers","body","JSON","stringify","fileName","name","fileSize","size","totalChunks","Math","ceil","CHUNK_SIZE","ok","Error","json","uploadChunk","chunk","chunkIndex","fileId","retryCount","formData","FormData","append","toString","CHUNK","status","error","RETRY_ATTEMPTS","Promise","resolve","setTimeout","RETRY_DELAY","verifyUpload","VERIFY","result","verified","uploadFile","callbacks","uploadedChunks","min","progress","round","onProgress","onStatusChange","onSuccess","onError"],"sources":["/media/tarun/ITB/code/work/thinkelution/Videolution-Analyzer-App/src/Components/Upload/services/fileUploadService.ts"],"sourcesContent":["// src/components/Upload/services/fileUploadService.ts\n\nimport { API_ENDPOINTS } from \"../../../config/api.config\";\nimport { UPLOAD_CONFIG } from \"../constants/upload.constants\";\nimport {\n  UploadProgressCallback,\n  ChunkUploadResponse,\n  UploadInitializeResponse,\n} from \"../types/upload.types\";\n\nexport class FileUploadService {\n  private async createChunk(\n    file: File,\n    start: number,\n    end: number,\n  ): Promise<Blob> {\n    return file.slice(start, end);\n  }\n\n  private async initializeUpload(\n    file: File,\n  ): Promise<UploadInitializeResponse> {\n    const response = await fetch(API_ENDPOINTS.UPLOAD.INITIALIZE, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        fileName: file.name,\n        fileSize: file.size,\n        totalChunks: Math.ceil(file.size / UPLOAD_CONFIG.CHUNK_SIZE),\n      }),\n    });\n\n    if (!response.ok) {\n      throw new Error(\"Failed to initialize upload\");\n    }\n\n    return response.json();\n  }\n\n  private async uploadChunk(\n    chunk: Blob,\n    chunkIndex: number,\n    fileId: string,\n    retryCount: number = 0,\n  ): Promise<ChunkUploadResponse> {\n    const formData = new FormData();\n    formData.append(\"chunk\", chunk);\n    formData.append(\"chunkIndex\", chunkIndex.toString());\n    formData.append(\"fileId\", fileId);\n\n    try {\n      const response = await fetch(API_ENDPOINTS.UPLOAD.CHUNK, {\n        method: \"POST\",\n        body: formData,\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return response.json();\n    } catch (error) {\n      if (retryCount < UPLOAD_CONFIG.RETRY_ATTEMPTS) {\n        // Wait before retrying\n        await new Promise((resolve) =>\n          setTimeout(resolve, UPLOAD_CONFIG.RETRY_DELAY),\n        );\n        return this.uploadChunk(chunk, chunkIndex, fileId, retryCount + 1);\n      }\n      throw error;\n    }\n  }\n\n  private async verifyUpload(fileId: string): Promise<boolean> {\n    const response = await fetch(`${API_ENDPOINTS.UPLOAD.VERIFY}/${fileId}`, {\n      method: \"POST\",\n    });\n\n    if (!response.ok) {\n      throw new Error(\"Upload verification failed\");\n    }\n\n    const result = await response.json();\n    return result.verified;\n  }\n\n  public async uploadFile(\n    file: File,\n    callbacks: UploadProgressCallback,\n  ): Promise<void> {\n    try {\n      // Initialize upload\n      const { fileId } = await this.initializeUpload(file);\n\n      const totalChunks = Math.ceil(file.size / UPLOAD_CONFIG.CHUNK_SIZE);\n      let uploadedChunks = 0;\n\n      // Upload chunks\n      for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {\n        const start = chunkIndex * UPLOAD_CONFIG.CHUNK_SIZE;\n        const end = Math.min(start + UPLOAD_CONFIG.CHUNK_SIZE, file.size);\n\n        // Create and upload chunk\n        const chunk = await this.createChunk(file, start, end);\n        await this.uploadChunk(chunk, chunkIndex, fileId);\n\n        // Update progress\n        uploadedChunks++;\n        const progress = Math.round((uploadedChunks / totalChunks) * 100);\n        callbacks.onProgress(progress);\n\n        // Update status based on progress thresholds\n        if (progress >= 30 && progress < 60) {\n          callbacks.onStatusChange(\"processing\");\n        } else if (progress >= 60 && progress < 100) {\n          callbacks.onStatusChange(\"finalizing\");\n        }\n      }\n\n      // Verify upload\n      const verified = await this.verifyUpload(fileId);\n      if (!verified) {\n        throw new Error(\"Upload verification failed\");\n      }\n\n      callbacks.onStatusChange(\"done\");\n      callbacks.onSuccess();\n    } catch (error) {\n      callbacks.onError(error as Error);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}