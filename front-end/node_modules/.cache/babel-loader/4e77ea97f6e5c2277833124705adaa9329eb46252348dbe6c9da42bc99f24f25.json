{"ast":null,"code":"// src/Components/services/fileUploadService.ts\n\nconst API_BASE_URL = \"http://0.0.0.0:8080\";\nexport class FileUploadService {\n  async initializeUpload(file) {\n    console.log(\"Initializing upload for file:\", file.name);\n    const requestData = {\n      fileName: file.name,\n      fileSize: file.size,\n      totalChunks: Math.ceil(file.size / (1024 * 1024)) // 1MB chunks\n    };\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload/initialize`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json\"\n        },\n        body: JSON.stringify(requestData)\n      });\n      if (!response.ok) {\n        throw new Error(`Server error: ${response.status}`);\n      }\n      const data = await response.json();\n      if (!data.fileId) {\n        throw new Error(\"Invalid response: missing fileId\");\n      }\n      return {\n        fileId: data.fileId,\n        fileName: data.fileName || file.name,\n        fileSize: data.fileSize || file.size\n      };\n    } catch (error) {\n      console.error(\"Initialize upload error:\", error);\n      throw error;\n    }\n  }\n  parseSrtContent(content) {\n    const segments = [];\n    const pattern = /(\\d{2}:\\d{2}:\\d{2},\\d{3}) --> (\\d{2}:\\d{2}:\\d{2},\\d{3})\\n([\\s\\S]*?)(?=\\n\\n|\\n*$)/g;\n    let match;\n    while ((match = pattern.exec(content)) !== null) {\n      segments.push({\n        startTime: match[1],\n        endTime: match[2],\n        text: match[3].trim()\n      });\n    }\n    return segments;\n  }\n  async uploadChunk(chunk, chunkIndex, totalChunks, fileId, metadata) {\n    console.log(`Uploading chunk ${chunkIndex + 1}/${totalChunks}`);\n    const formData = new FormData();\n    formData.append(\"chunk\", chunk);\n    if (metadata) {\n      formData.append(\"metadata\", JSON.stringify(metadata));\n    }\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload/chunk`, {\n        method: \"POST\",\n        headers: {\n          \"X-File-Id\": fileId,\n          \"X-Chunk-Index\": chunkIndex.toString(),\n          Accept: \"application/json\"\n        },\n        body: formData\n      });\n      if (!response.ok) {\n        throw new Error(`Chunk upload failed: ${response.status}`);\n      }\n      const data = await response.json();\n      console.log(`Chunk ${chunkIndex + 1} response:`, data);\n      return data;\n    } catch (error) {\n      console.error(`Failed to upload chunk ${chunkIndex}:`, error);\n      throw error;\n    }\n  }\n  async uploadFile(file, callbacks) {\n    try {\n      console.log(\"Starting upload for file:\", file.name);\n      const initResponse = await this.initializeUpload(file);\n      console.log(\"Upload initialized:\", initResponse);\n      const CHUNK_SIZE = 1024 * 1024; // 1MB\n      const totalChunks = Math.ceil(file.size / CHUNK_SIZE);\n      let uploadedChunks = 0;\n      callbacks.onStatusChange(\"analyzing\");\n\n      // Parse SRT content\n      const content = await file.text();\n      const subtitleSegments = this.parseSrtContent(content);\n      console.log(\"Parsed subtitle segments:\", subtitleSegments.length);\n\n      // Upload chunks with metadata\n      for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {\n        const start = chunkIndex * CHUNK_SIZE;\n        const end = Math.min(start + CHUNK_SIZE, file.size);\n        const chunk = file.slice(start, end);\n        const metadata = subtitleSegments[chunkIndex];\n        const response = await this.uploadChunk(chunk, chunkIndex, totalChunks, initResponse.fileId, metadata);\n        uploadedChunks++;\n        callbacks.onProgress(response.progress);\n        callbacks.onStatusChange(response.status);\n\n        // Small delay between chunks\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n      console.log(\"Upload completed successfully\");\n      callbacks.onStatusChange(\"done\");\n      callbacks.onSuccess();\n    } catch (error) {\n      console.error(\"Upload failed:\", error);\n      callbacks.onError(error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n}","map":{"version":3,"names":["API_BASE_URL","FileUploadService","initializeUpload","file","console","log","name","requestData","fileName","fileSize","size","totalChunks","Math","ceil","response","fetch","method","headers","Accept","body","JSON","stringify","ok","Error","status","data","json","fileId","error","parseSrtContent","content","segments","pattern","match","exec","push","startTime","endTime","text","trim","uploadChunk","chunk","chunkIndex","metadata","formData","FormData","append","toString","uploadFile","callbacks","initResponse","CHUNK_SIZE","uploadedChunks","onStatusChange","subtitleSegments","length","start","end","min","slice","onProgress","progress","Promise","resolve","setTimeout","onSuccess","onError","String"],"sources":["/media/tarun/ITB/code/work/thinkelution/Videolution-Analyzer-App/src/Components/Upload/services/fileUploadService.ts"],"sourcesContent":["// src/Components/services/fileUploadService.ts\n\nimport {\n  UploadProgressCallback,\n  ChunkUploadResponse,\n  UploadInitializeResponse,\n} from \"../utils/upload.types\";\n\nconst API_BASE_URL = \"http://0.0.0.0:8080\";\n\ninterface SubtitleSegment {\n  startTime: string;\n  endTime: string;\n  text: string;\n}\n\nexport class FileUploadService {\n  private async initializeUpload(\n    file: File,\n  ): Promise<UploadInitializeResponse> {\n    console.log(\"Initializing upload for file:\", file.name);\n\n    const requestData = {\n      fileName: file.name,\n      fileSize: file.size,\n      totalChunks: Math.ceil(file.size / (1024 * 1024)), // 1MB chunks\n    };\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload/initialize`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json\",\n        },\n        body: JSON.stringify(requestData),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Server error: ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      if (!data.fileId) {\n        throw new Error(\"Invalid response: missing fileId\");\n      }\n\n      return {\n        fileId: data.fileId,\n        fileName: data.fileName || file.name,\n        fileSize: data.fileSize || file.size,\n      };\n    } catch (error) {\n      console.error(\"Initialize upload error:\", error);\n      throw error;\n    }\n  }\n\n  private parseSrtContent(content: string): SubtitleSegment[] {\n    const segments: SubtitleSegment[] = [];\n    const pattern =\n      /(\\d{2}:\\d{2}:\\d{2},\\d{3}) --> (\\d{2}:\\d{2}:\\d{2},\\d{3})\\n([\\s\\S]*?)(?=\\n\\n|\\n*$)/g;\n\n    let match;\n    while ((match = pattern.exec(content)) !== null) {\n      segments.push({\n        startTime: match[1],\n        endTime: match[2],\n        text: match[3].trim(),\n      });\n    }\n\n    return segments;\n  }\n\n  private async uploadChunk(\n    chunk: Blob,\n    chunkIndex: number,\n    totalChunks: number,\n    fileId: string,\n    metadata?: SubtitleSegment,\n  ): Promise<ChunkUploadResponse> {\n    console.log(`Uploading chunk ${chunkIndex + 1}/${totalChunks}`);\n\n    const formData = new FormData();\n    formData.append(\"chunk\", chunk);\n\n    if (metadata) {\n      formData.append(\"metadata\", JSON.stringify(metadata));\n    }\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload/chunk`, {\n        method: \"POST\",\n        headers: {\n          \"X-File-Id\": fileId,\n          \"X-Chunk-Index\": chunkIndex.toString(),\n          Accept: \"application/json\",\n        },\n        body: formData,\n      });\n\n      if (!response.ok) {\n        throw new Error(`Chunk upload failed: ${response.status}`);\n      }\n\n      const data = await response.json();\n      console.log(`Chunk ${chunkIndex + 1} response:`, data);\n\n      return data;\n    } catch (error) {\n      console.error(`Failed to upload chunk ${chunkIndex}:`, error);\n      throw error;\n    }\n  }\n\n  public async uploadFile(\n    file: File,\n    callbacks: UploadProgressCallback,\n  ): Promise<void> {\n    try {\n      console.log(\"Starting upload for file:\", file.name);\n\n      const initResponse = await this.initializeUpload(file);\n      console.log(\"Upload initialized:\", initResponse);\n\n      const CHUNK_SIZE = 1024 * 1024; // 1MB\n      const totalChunks = Math.ceil(file.size / CHUNK_SIZE);\n      let uploadedChunks = 0;\n\n      callbacks.onStatusChange(\"analyzing\");\n\n      // Parse SRT content\n      const content = await file.text();\n      const subtitleSegments = this.parseSrtContent(content);\n      console.log(\"Parsed subtitle segments:\", subtitleSegments.length);\n\n      // Upload chunks with metadata\n      for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {\n        const start = chunkIndex * CHUNK_SIZE;\n        const end = Math.min(start + CHUNK_SIZE, file.size);\n        const chunk = file.slice(start, end);\n\n        const metadata = subtitleSegments[chunkIndex];\n\n        const response = await this.uploadChunk(\n          chunk,\n          chunkIndex,\n          totalChunks,\n          initResponse.fileId,\n          metadata,\n        );\n\n        uploadedChunks++;\n        callbacks.onProgress(response.progress);\n        callbacks.onStatusChange(response.status);\n\n        // Small delay between chunks\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      }\n\n      console.log(\"Upload completed successfully\");\n      callbacks.onStatusChange(\"done\");\n      callbacks.onSuccess();\n    } catch (error) {\n      console.error(\"Upload failed:\", error);\n      callbacks.onError(\n        error instanceof Error ? error : new Error(String(error)),\n      );\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}