{"ast":null,"code":"// src/Components/services/fileUploadService.ts\n\nconst API_BASE_URL = \"http://0.0.0.0:8080\";\nexport class FileUploadService {\n  async initializeUpload(file) {\n    console.log(\"Initializing upload for file:\", file.name);\n    const requestData = {\n      fileName: file.name,\n      fileSize: file.size,\n      totalChunks: Math.ceil(file.size / (1024 * 1024)) // 1MB chunks\n    };\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload/initialize`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json\"\n        },\n        body: JSON.stringify(requestData)\n      });\n      if (!response.ok) {\n        throw new Error(`Server error: ${response.status}`);\n      }\n      const data = await response.json();\n      if (!data.fileId) {\n        throw new Error(\"Invalid response: missing fileId\");\n      }\n      return {\n        fileId: data.fileId,\n        fileName: data.fileName || file.name,\n        fileSize: data.fileSize || file.size\n      };\n    } catch (error) {\n      console.error(\"Initialize upload error:\", error);\n      throw error;\n    }\n  }\n  async uploadChunk(chunk, chunkIndex, totalChunks, fileId, subtitleSegment) {\n    console.log(`Uploading chunk ${chunkIndex + 1}/${totalChunks}`);\n    const formData = new FormData();\n    formData.append(\"chunk\", chunk);\n    if (subtitleSegment) {\n      formData.append(\"metadata\", JSON.stringify(subtitleSegment));\n    }\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload/chunk`, {\n        method: \"POST\",\n        headers: {\n          \"X-File-Id\": fileId,\n          \"X-Chunk-Index\": chunkIndex.toString(),\n          Accept: \"application/json\"\n        },\n        body: formData\n      });\n      if (!response.ok) {\n        throw new Error(`Chunk upload failed: ${response.status}`);\n      }\n      const data = await response.json();\n      if (!data.received) {\n        throw new Error(\"Chunk upload failed\");\n      }\n      return data;\n    } catch (error) {\n      console.error(`Failed to upload chunk ${chunkIndex}:`, error);\n      throw error;\n    }\n  }\n  parseSrtContent(content) {\n    const segments = [];\n    const pattern = /(\\d{2}:\\d{2}:\\d{2},\\d{3}) --> (\\d{2}:\\d{2}:\\d{2},\\d{3})\\n([\\s\\S]*?)(?=\\n\\n|\\n*$)/g;\n    let match;\n    while ((match = pattern.exec(content)) !== null) {\n      segments.push({\n        startTime: match[1],\n        endTime: match[2],\n        text: match[3].trim()\n      });\n    }\n    return segments;\n  }\n  async uploadFile(file, callbacks) {\n    try {\n      console.log(\"Starting upload for file:\", file.name);\n      const initResponse = await this.initializeUpload(file);\n      console.log(\"Upload initialized:\", initResponse);\n      const CHUNK_SIZE = 1024 * 1024; // 1MB\n      const totalChunks = Math.ceil(file.size / CHUNK_SIZE);\n      let uploadedChunks = 0;\n      callbacks.onStatusChange(\"analyzing\");\n\n      // Parse SRT content\n      const content = await file.text();\n      const subtitleSegments = this.parseSrtContent(content);\n\n      // Upload chunks with metadata\n      for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {\n        const start = chunkIndex * CHUNK_SIZE;\n        const end = Math.min(start + CHUNK_SIZE, file.size);\n        const chunk = file.slice(start, end);\n        const subtitleSegment = subtitleSegments[chunkIndex];\n        const response = await this.uploadChunk(chunk, chunkIndex, totalChunks, initResponse.fileId, subtitleSegment);\n        uploadedChunks++;\n        callbacks.onProgress(response.progress);\n        callbacks.onStatusChange(response.status);\n      }\n\n      // Get final analysis results\n      const analysisResponse = await fetch(`${API_BASE_URL}/api/analysis/results?fileId=${initResponse.fileId}`);\n      if (!analysisResponse.ok) {\n        throw new Error(\"Failed to get analysis results\");\n      }\n      const analysisResults = await analysisResponse.json();\n      console.log(\"Upload completed successfully\");\n      callbacks.onStatusChange(\"done\");\n      callbacks.onSuccess();\n      return analysisResults;\n    } catch (error) {\n      console.error(\"Upload failed:\", error);\n      callbacks.onError(error instanceof Error ? error : new Error(String(error)));\n      throw error;\n    }\n  }\n}","map":{"version":3,"names":["API_BASE_URL","FileUploadService","initializeUpload","file","console","log","name","requestData","fileName","fileSize","size","totalChunks","Math","ceil","response","fetch","method","headers","Accept","body","JSON","stringify","ok","Error","status","data","json","fileId","error","uploadChunk","chunk","chunkIndex","subtitleSegment","formData","FormData","append","toString","received","parseSrtContent","content","segments","pattern","match","exec","push","startTime","endTime","text","trim","uploadFile","callbacks","initResponse","CHUNK_SIZE","uploadedChunks","onStatusChange","subtitleSegments","start","end","min","slice","onProgress","progress","analysisResponse","analysisResults","onSuccess","onError","String"],"sources":["/media/tarun/ITB/code/work/thinkelution/Videolution-Analyzer-App/src/Components/Upload/services/fileUploadService.ts"],"sourcesContent":["// src/Components/services/fileUploadService.ts\n\nimport {\n  UploadProgressCallback,\n  ChunkUploadResponse,\n  UploadInitializeResponse,\n  AnalysisResults,\n} from \"../utils/upload.types\";\n\nconst API_BASE_URL = \"http://0.0.0.0:8080\";\n\ninterface SubtitleSegment {\n  startTime: string;\n  endTime: string;\n  text: string;\n}\n\nexport class FileUploadService {\n  private async initializeUpload(\n    file: File,\n  ): Promise<UploadInitializeResponse> {\n    console.log(\"Initializing upload for file:\", file.name);\n\n    const requestData = {\n      fileName: file.name,\n      fileSize: file.size,\n      totalChunks: Math.ceil(file.size / (1024 * 1024)), // 1MB chunks\n    };\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload/initialize`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json\",\n        },\n        body: JSON.stringify(requestData),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Server error: ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      if (!data.fileId) {\n        throw new Error(\"Invalid response: missing fileId\");\n      }\n\n      return {\n        fileId: data.fileId,\n        fileName: data.fileName || file.name,\n        fileSize: data.fileSize || file.size,\n      };\n    } catch (error) {\n      console.error(\"Initialize upload error:\", error);\n      throw error;\n    }\n  }\n\n  private async uploadChunk(\n    chunk: Blob,\n    chunkIndex: number,\n    totalChunks: number,\n    fileId: string,\n    subtitleSegment?: SubtitleSegment,\n  ): Promise<ChunkUploadResponse> {\n    console.log(`Uploading chunk ${chunkIndex + 1}/${totalChunks}`);\n\n    const formData = new FormData();\n    formData.append(\"chunk\", chunk);\n\n    if (subtitleSegment) {\n      formData.append(\"metadata\", JSON.stringify(subtitleSegment));\n    }\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload/chunk`, {\n        method: \"POST\",\n        headers: {\n          \"X-File-Id\": fileId,\n          \"X-Chunk-Index\": chunkIndex.toString(),\n          Accept: \"application/json\",\n        },\n        body: formData,\n      });\n\n      if (!response.ok) {\n        throw new Error(`Chunk upload failed: ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      if (!data.received) {\n        throw new Error(\"Chunk upload failed\");\n      }\n\n      return data;\n    } catch (error) {\n      console.error(`Failed to upload chunk ${chunkIndex}:`, error);\n      throw error;\n    }\n  }\n\n  private parseSrtContent(content: string): SubtitleSegment[] {\n    const segments: SubtitleSegment[] = [];\n    const pattern =\n      /(\\d{2}:\\d{2}:\\d{2},\\d{3}) --> (\\d{2}:\\d{2}:\\d{2},\\d{3})\\n([\\s\\S]*?)(?=\\n\\n|\\n*$)/g;\n\n    let match;\n    while ((match = pattern.exec(content)) !== null) {\n      segments.push({\n        startTime: match[1],\n        endTime: match[2],\n        text: match[3].trim(),\n      });\n    }\n\n    return segments;\n  }\n\n  public async uploadFile(\n    file: File,\n    callbacks: UploadProgressCallback,\n  ): Promise<AnalysisResults> {\n    try {\n      console.log(\"Starting upload for file:\", file.name);\n\n      const initResponse = await this.initializeUpload(file);\n      console.log(\"Upload initialized:\", initResponse);\n\n      const CHUNK_SIZE = 1024 * 1024; // 1MB\n      const totalChunks = Math.ceil(file.size / CHUNK_SIZE);\n      let uploadedChunks = 0;\n\n      callbacks.onStatusChange(\"analyzing\");\n\n      // Parse SRT content\n      const content = await file.text();\n      const subtitleSegments = this.parseSrtContent(content);\n\n      // Upload chunks with metadata\n      for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {\n        const start = chunkIndex * CHUNK_SIZE;\n        const end = Math.min(start + CHUNK_SIZE, file.size);\n        const chunk = file.slice(start, end);\n\n        const subtitleSegment = subtitleSegments[chunkIndex];\n\n        const response = await this.uploadChunk(\n          chunk,\n          chunkIndex,\n          totalChunks,\n          initResponse.fileId,\n          subtitleSegment,\n        );\n\n        uploadedChunks++;\n        callbacks.onProgress(response.progress);\n        callbacks.onStatusChange(response.status);\n      }\n\n      // Get final analysis results\n      const analysisResponse = await fetch(\n        `${API_BASE_URL}/api/analysis/results?fileId=${initResponse.fileId}`,\n      );\n\n      if (!analysisResponse.ok) {\n        throw new Error(\"Failed to get analysis results\");\n      }\n\n      const analysisResults: AnalysisResults = await analysisResponse.json();\n\n      console.log(\"Upload completed successfully\");\n      callbacks.onStatusChange(\"done\");\n      callbacks.onSuccess();\n\n      return analysisResults;\n    } catch (error) {\n      console.error(\"Upload failed:\", error);\n      callbacks.onError(\n        error instanceof Error ? error : new Error(String(error)),\n      );\n      throw error;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}